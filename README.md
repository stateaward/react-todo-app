# 😶‍🌫️ Intro
본 소스는 `리액트를 다루는 기술` 속 일정관리(TodoList)를 구현한 코드입니다.

# 🥸 Project Setup
### 최초 셋팅
```
yarn create react-app react-todo-app
cd react-todo-app
yarn add sass classnames react-icons
```
### 이후 시작
```
yarn add
yarn start
```

# 🤩 TIL
### props와 children
- props : 부모 컴포넌트가 자식에게 주는 값
  - 사용 예)
    - `<TodoList todos={todos}/>` todos 라는 변수명으로, 'todos' 라는 값을 보냄
    - 자식 컴포넌트에선 `const TodoList = ({todos}) => {...}`의 형태로 todos 변수명을 받아서 사용함
- children은 props의 한 예로, 태그 사이에 넣은 값을 children 이란 이름으로 보냄
  - 사용 예)
    - `<TodoList todos={todos}>테스트값</TodoList>` 처럼 태그 사이에 데이터를 넣음
    - 자식 컴포넌트에선 `const TodoList = ({todos, children}) => {...}` 처럼 비구조화 할당으로 값을 가져와서 사용

### state란?
- 컴포넌트에서 자체적으로 사용하는 값 (like 컴포넌트의 지역 변수)
- 현 예제인 함수형 컴포넌트에선 `const [변수명, set변수명] = useState(초기값);` 으로 선언하여 사용한다.
  - "`useState()` 함수를 실행시켜, 내가 사용할 변수와 setter를 반환받는다!"

### JSX에서 {}의 역할은?
- JSX 내에서 동적 데이터/로직/Javascript처리를 하기 위해 사용
  - 마치 JSP에서 Java코드를 쓰기 위해 스크립틀릿(`<%...%>`)을 사용하는 것과 같은 역할

### 왜 map을 사용할 땐, key props를 지정해야 할까?
- key를 지정하면 React에서 컴포넌트의 랜더링 여부(추가, 생성, 제거 등)를 탐색(인덱싱)하기 쉬워짐
- key를 지정하지 않으면, 모든 컴포넌트를 비교해야해서 성능 저하가 발생함

### useCallback();
- `useCallback(함수, [검사값])` 검사값이 변경되었을 때에만 함수를 생성하는 Hook이다.
- 함수를 memoize -> 재사용하기 위해서 사용(랜더링 성능 최적화)
- 검사값에 따른 랜더링 비교
  - `[]` : 검사값이 비어있으므로, 최초 랜더링시에만 함수를 선언하고 이후 계속 재사용한다
  - `[number]` : number 값이 변경되었을 떄에만, 함수를 다시 선언
- 사용 이유
  - 자식 컴포넌트에게 props로 함수를 전달할 때 사용 -> 자식 컴포넌트의 불필요한 랜더링을 방지
  - 함수 변경이 없거나, 연산이 큰 함수를 최초에만 선언하기 위해서 사용

### useCallback()과 useEffect()의 차이
- useCallback : 콜백함수를 자식에게 전달해줄 때 사용 / 자주 렌더링 위험이 있는 요소를 성능 최적화를 위해 사용
  - `const onChange = useCallback(e => {...});`
- useEffect : API 통신(data fetch), 이벤트 리스너 추가, DOM 업데이트 등 -> 사이드 이펙트 방지를 위해 사용
  - `useEffect(()=>{...});` 함수 호출!

### useEffect(), 넌 무엇이니?
- 사이드 이펙트를 방지하기 위해서 사용함
- 상세 사례
  - API Fetching : 컴포넌트 내에 axios를 선언해놓았는데, 해당 컴포넌트가 부모에 의해 계속 재랜더링된다면? 불필요한 api 요청이 계속 반복됨(side effect 발생)
  - 이벤트 리스너 추가/제거 : 컴포넌트 마운트 될 때, 이벤트 추가하고. 해제될 때 이벤트 제거를 위해서
  - DOM 업데이트 시 처리 등

### useCallback()에서 종속성 배열을 넣는 이유?
- ⭐️ 결론 : 함수가 어떤 식으로든 state 등의 값에 의존적일 때 유용함 -> 항상 최신의 값을 받기 위해
- 종속성 배열(=검사값 배열)은 해당 값이 변경되었을 때 함수를 다시 랜더링하는 역할을 한다.
- onInsert와 onRemove함수를 보면 `useCallback(()=>{...}, [todos]);` 로 App.js의 `todos`를 종속성 배열로 받고 있음
  - 현재 코드 내부적으로 `setTodos()`를 통해 todos 배열에 새로운 할일을 추가중임. 
  이때, `todos.concat(...)`으로 기존 배열을 참고하여 추가/제거가 이루어지는데 todos가 변경되었을 때 새롭게 랜더링하지 않으면,
  과거의 데이터를 참조할 수 있는 등 예기치 않은 오류가 발생할 수 있음.
- 따라서 함수 내에 todos의 데이터를 활용하고 있으므로, 종속성 배열에 추가하여 항상 최신의 데이터를 참조할 수 있도록 재랜더링이 필요함
- 일반적으로 함수가 항상 최신의 state와 props에 액세스할 수 있도록, useCallback에 필요한 모든 종속성을 추가하는 것이 좋음

### `array.map();` 함수란?
- 배열 내 element 값을 변경하여 새로운 배열을 반환하는 함수
- 각 요소들이 콜백함수로 전달되고, 처리된 결과(요서)가 return되면 그 요소들을 모아 새로운 배열을 만들어 반환함
- `arr.map(callback(currentValue[, index[, array]])[, thisArg])`
  - `arr.map(item => item*2)` 처럼 단일 변수와 단일 라인으로 된 문장은 `()=>{}` 괄호와 return을 생략해도 동작함

### onToggle 에서 todos.map 함수를 사용한 이유?
- 체크박스에 체크하는 건, 결국 기존 todos 배열의 값을 업데이트 하는 행위 -> setTodos()의 실행
- setTodos()는 todos 배열을 받아야 하므로, 결국 배열을 전달해줘야함
- 따라서 입력받은 id에 맞는 배열 요소가 있다면, 해당 요소의 값만 변경을 하여 새롭게 만들어진 배열을 반환하기 위해, map 함수를 사용함.

### map, filter, concat() 함수를 사용하는 이유?
- ⭐️ 리액트의 불변성을 유지하기 위해서
  - 불변성이란? 결론적으로 변수가 참조하고 있는 메모리의 영역 값이 변하지 않는다는 의미
- 1) 효율적인 랜더링을 위해서
  - 리액트는 변경된 부분만 랜더링을 다시 하는 형태로, 그 성능을 유지하고 있음
  - 모든 속성을 하나하나 비교하는게 아닌, 얕은 비교를 통해 상태 업데이트를 수행함.
  - 따라서 state 값이 변경되었을 때, 새로운 값으로 랜더링을 하기 위해선 새로운 참조값을 가진 배열을 할당하여 생성을 하는 것 -> 얕은 비교에게 '나 변경됐어'라고 알려주기 위해서
- 2) 사이드 이펙트 방지
  - 참조타입(배열, 객체 등)의 경우, 값 변경 시에 원본 데이터가 변경되는 등. 불변성이 지켜지지 않는 이슈가 발생할 수 있음.
  - 원본 데이터의 불변성이 지켜지지 않는다면, 프로그램의 복잡도도 향상됨.
  - 따라서 불변성을 지킴으로써 사이드 이펙트를 방지하고 복잡도를 낮출 수 있음.
- 유지 방법(`useState()`의 대상 타입)
  - 원시타입 : 값 바로 할당 가능
  - 배열 : map, filter, concat, reduce .. 등
  - 객체 : 새로운 객체 할당
- 기존에 선언한 값을 활용하지 않고 새로운 값으로 대체하는 방식은, 리소스 낭비처럼 보일 수 있지만 실제로는 올바른 동작과 성능을 보장하는 방식임.
- 참고 : https://hsp0418.tistory.com/171

